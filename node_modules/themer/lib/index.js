'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _minimist = require('minimist');

var _minimist2 = _interopRequireDefault(_minimist);

var _themer = require('./themer');

var _themer2 = _interopRequireDefault(_themer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = {
  out: msg => {
    process.stdout.write(`${msg}\n`);
  },
  err: msg => {
    process.stderr.write(`${msg}\n`);
  }
};

const args = (parsedArgs => {
  try {
    if (parsedArgs.colors === undefined) {
      throw new Error('Please provide a package name or file containing colors');
    }
    if (parsedArgs.template === undefined) {
      throw new Error('Please provide at least one template to render');
    }
    if (parsedArgs.out === undefined) {
      throw new Error('Please provide a directory to write output to');
    }
  } catch (e) {
    log.err(e.message);
    process.exit(1);
  }
  return _extends({}, parsedArgs, {
    template: typeof parsedArgs.template === 'string' ? [parsedArgs.template] : parsedArgs.template,
    out: _path2.default.resolve(parsedArgs.out)
  });
})((0, _minimist2.default)(process.argv.slice(2), {
  string: ['colors', 'template', 'out'],
  alias: {
    'colors': 'c',
    'template': 't',
    'out': 'o'
  }
}));

(0, _themer2.default)(args.colors, args.template, args.out, args).subscribe(evt => log.out(evt), err => {
  log.err(err);process.exit(1);
}, () => process.exit(0));